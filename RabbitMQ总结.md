## 1. MQ特殊队列

1. **优先级队列**：不同于先进先出的队列，优先级高的消息具备优先被消费的特权，这样可以为下游提供不同级别的消息保证。**如果消费者的消费速度大于生产者的速度，这种优先级的设置没有意义。**
2. **延迟队列**:消息被发送之后，等待特殊时间后，消费者才拿到这个消息。延迟队列一般分两种：
   + 基于消息的延迟
   + 基于队列的延迟
   + RabbitMQ借助消息的TTL(Time To Live)和死信队列可以实现延迟消息。
3. **死信队列**：消息没有被正确投递，可以进入死信队列；
4. **回退队列：**如果消费者在消费时发生异常，没有进行ACK，进而发生回滚消息的操作之后消息始终会放在队列的顶部，然后不断被处理和回滚，导致队列陷入死循环。为解决这个问题，可以设置回退队列。
5. **重试队列**：可以看成一种回退队列，具体指消费端消费消息失败时，为防止消息无故丢失而重新将消息回滚到 Broker 中

## 2. 消费模式

#### 2.1 消费者获取消息模式

- 推模式，**是指由 Broker 主动推送消息至消费端，实时性较好，不过需要一定的流制机制来确保服务端推送过来的消息不会压垮消费端。
- **拉模式，**是指消费端主动向 Broker 端请求拉取（一般是定时或者定量）消息，实时性较推模式差，但是可以根据自身的处理能力而控制拉取的消息量。

#### 2.2 消息投递模式

+ 点对点
+ 发布订阅

#### 2.3 消息的幂等性

确保消息在生产者和消费者之间进行传输，一般有三种传输保障（Delivery Guarantee）：

- **At most once，**至多一次，消息可能丢失，但绝不会重复传输。
- **At least once，**至少一次，消息绝不会丢，但是可能会重复。
- **Exactly once，**精确一次，每条消息肯定会被传输一次且仅一次。



## 3. MQ的特殊功能

1. 消息过滤：kafka可以将不同类别的消息发送到不同的Topic中，由此可以实现某种意义上的消息过滤。kafka还可以在客户端提供Consumer Interceptor 接口或者 Kafka Stream 的 Filter 功能进行消息过滤。
2. 多租户：RabbitMQ支持对租户技术，每个租户表示一个VHost，本质上是一个独立的小型MQ服务器，有自己独立的队列、交换器及绑定关系，并且有自己独立的权限。
3. 多协议：RabbitMQ支持MQTT协议



## 4. Rabbit API

1. **排他性队列**：适用于只对当前连接可见，连接断开自动删除的场景。它只区分连接，不区分通道。同一连接的不同通道可以访问。连接断开时，不关是否声明持久化都会被删除。

2. **直接回复：**官方文档地址https://www.rabbitmq.com/direct-reply-to.html

   使用方式：

   **对于RPC客户端：**

   - RPC客户端创建消费者的时候队列指定为伪队列`amq.rabbitmq.reply-to`，使用非手动ack模式(autoAck=true)进行消费，伪队列`amq.rabbitmq.reply-to`不需要显式声明，当然如果需要的话也可以显式声明。
   - 发布消息的时候，消息属性中的`reply-to`属性需要指定为`amq.rabbitmq.reply-to`。

   **对于RPC服务端：**

   - RPC服务端接收消息后感知消息属性中的`reply-to`属性存在，它应该通过默认的交换器(名称为””)和`reply-to`属性作为路由键发送回复消息，那么该回复消息就会直接投递到RPC客户端的消费者中。
   - 如果RPC服务端需要进行一些长时间的计算逻辑，可能需要探测RPC服务端是否存活，可以使用一个一次性使用的信道对`reply-to`属性做一次队列声明，如果声明成功，队列`amq.rabbitmq.reply-to`并不会创建，如果声明失败，那么说明客户端已经失去连接。

3. **优先级队列**：3.5.0之后支持优先级队列。优先级用数字表示，最大255，推荐1到10之间。声明队列时可以指定最大优先级

   ```java
   Channel ch = ...;
   Map<String, Object> args = new HashMap<String, Object>();
   args.put("x-max-priority", 10);
   ch.queueDeclare("my-priority-queue", true, false, false, args);
   ```

   生产者发布消息时可以通过指定属性priority设置优先级。仅当消息有积压时，优先级才起作用。

4. **消费者优先级**：RabbitMQ可以指定消费者优先级。高优先级的消费者如果处于活跃状态下，优先接受消息。

5. **消费者预取**：AMQP 0-9-1协议中定义了`basic.qos`方法用于限制信道或者连接上的未确认消息数量，这个消息数据量命名为`prefetch_count`。信道其实并不是限制未确认消息数量的理想范畴，因为单个信道有可能有多个消费者订阅多个不同的队列，所以信道和队列需要为发送的每个消息相互协调，以确保消息总数量不超过限制，造成了性能下降，单机性能出现瓶颈，在集群方案中耗时更加严重。

## 5. Exchange类型

1. fanout： 当发送一条消息时，它会把消息投递到所有附加在此交换机的队列，适合于发布订阅模式；
2. topic: 将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“\*”匹配不多不少一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.*” 只会匹配到“audit.irs”。
3. direct:  如果路由键匹配的话，消息被投递到相应的队列。当一个携带着路由值为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。







