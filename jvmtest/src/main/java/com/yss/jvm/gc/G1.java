package com.yss.jvm.gc;

/*
    1. 吞吐量：
       吞吐量关注的是，在一个指定的时间内，最大化一个应用的工作量
       如下方式来衡量一个系统吞吐量的好坏：
              在一个小时内同一事务（或者任务、请求）完成的次数（tps）
              数据库一个小时可以完成多少次查询
       对于关注吞吐量的系统，卡顿是可以接收的，因为这个系统关注长时间的大量任务的执行能力，
       单次快速的响应并不值得考虑
    2. 响应能力：
       响应能力指一个程序或者系统对请求是否能够及时响应，比如：
             一个桌面UI能多块响应一个事件
             一个网站能够多块返回一个页面请求
             数据库能够多块返回查询结果
       对于这类对响应能力敏感的场景，长时间的停顿是无法接受的。
    3. G1收集器是一个面向服务器端的垃圾收集器，适用于多核处理器、大内存的服务器端系统。
       它满足短时间gc停顿的同时达到一个较高的吞吐量
    4. G1收集器设计目标：
          1.与应用线程同时工作，几乎不需要STW
          2.整理剩余空间，不产生碎片（CMS只在FullGC时，用STW整理内存碎片）
          3.GC停顿更加可控
          4.不牺牲系统的吞吐量
          5.gc不需要额外的内存空间（CMS需要预留空间存储浮动垃圾）
    5. G1的设计规划就是要替换掉CMS
          G1在某些方面弥补了CMS的不足，比如，CMS使用的是mark-sweep算法，自然会产生碎片；然后G1基于copying算法，高效
          的整理剩余内存，而不需要管理内存碎片。

    6. G1收集器的堆结构
        1. heap被划分成一个个相等的内存区域（Regions），每个Region都有一个分代角色：eden、survivor、old
        2. 对每个角色的数量并没有强制的限定，也就是说对每种分代的大小，可以动态变化
        3. G1最大的特点是高效的执行回收，优先去执行哪些大量对象可回收的区域（Region）
        4. G1使用了gc停顿可预测模型，来满足用户设定的gc停顿时间，根据用户设定的目标时间，G1会自动地选择哪些region要清除，
           一次清除多少个region
        5. G1从多个region中复制存活的对象，然后集中放入一个region中，同时整理、清除内存。并且G1只是特定地整理几个Region，停顿时间明显减少

   7. G1重要的概念
        1. 分区（Region）：G1采取了不同的策略来解决并行、串行和CMS收集器的碎片、暂停时间不可控等问题。G1将整个堆
                          分成大小相同的分区（Region）
                          每个分区都可能是年轻代也可能是老年代，但是在同一时刻只能属于某个代。年轻代、Survivor、Old这次概念
                          还在，称为逻辑上的概念。
                          在物理上不需要连续，则带来了额外的好处----有些分区内垃圾对象特别多，有的分区内垃圾对象很少，G1会
                          优先回收垃圾对象特别多的分区，这样可以花费较少的时间来回收这些分区的垃圾，这也就是G1名字的由来，即
                          首先收集垃圾最多的分区。
        2. 收集集合（CSet）：一组可被回收的分区集合。在CSet中存活的数据会在GC过程中被移动到另一个可用分区，CSet中的分区可以来自
                          eden空间、Survivor空间或者老年代
        3. 一记忆集合（RSet）：Reset记录了其他Region中的对象引用本Region中对象的关系，属于Points-into结构（谁引用了我的对象）
                          RSet的价值在于使得收集器不需要扫描整个堆找到了谁引用了当前分区中的对象，只需要扫描RSet即可。


































 */
public class G1 {
}
