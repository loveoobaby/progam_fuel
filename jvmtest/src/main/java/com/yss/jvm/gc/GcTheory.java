package com.yss.jvm.gc;

/**
 *  1. JVM运行时数据区：
 *    线程共享：方法区、堆
 *    线程独享：虚拟机栈、本地方法栈、程序计数器
 *  2. 垃圾回收主要在堆上进行、其他区域进行垃圾回收的性价比较低，但商用的虚拟机都会在方法区进行垃圾回收
 *  3. Java虚拟机栈：描述的是Java方法的执行模型，每个方法执行的时候会创建一个栈帧Frame，用于存放局部变量表，操作数栈、动态链接、方法出口等信息。
 *                  一个方法的执行过程，就是这个方法对应的栈帧的入栈出栈过程
 *  4. 堆：存放对象的实例，是Java虚拟机管理内存中最大的一块，是GC的主要工作区域
 *  5. 方法区：存放了每个Class的结构信息，包括常量池、字段描述、方法描述，是GC的非主要工作区域。
 *
 *  6. 垃圾判断的算法：引用计数算法、根搜索算法
 *        根搜索算法：基本思路是通过一系列的称为GC Roots的点作为起始进行向下搜索，当一个对象到GC Roots没有任何引用链（Reference chain）
 *                  相连，则证明此对象是不可用的
 *        方法区类回收需要满足如下3个条件：
 *           1. 该类的所有实例都已经被GC，也就是说JVM中不存在该Class的任何实例
 *           2. 加载该类的ClassLoader已经被GC
 *           3. 该类对应的java.lang.Class对象没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法
 *        方法区主要回收：废弃常量与无用类
 *  7. JVM常见的GC算法：
 *        标记-清除算法（Mark-Sweep）
 *        标记-压缩算法（Mark-Compact）
 *        复制算法（Copying）
 *        分代算法（Generational）
 *  8. 标记-清除算法（Mark-sweep）：算法分为标记与清除两个阶段，首先标记出所有需要回收的对象，然后回收所有需要回收的对象
 *        缺点：
 *           效率问题：标记和清除两个过程效率都不高，需要扫描所有对象。堆越大，GC越慢
 *           空间问题：标记清除后会产生大量不连续的空间，GC次数越多，碎片越严重
 *  9. 复制收集算法：可用内存缩小为原来的一半，代价高昂
 *       现在的商业虚拟机都是用来这一种收集算法来回收新生代
 *       将内存分为一块较大的Eden空间和2块较小的survivor空间，每次使用eden和其中一块survivor。当回收时将Eden和survivor还存活的
 *       对象一次性copy到另一块survivor空间上，然后清理掉eden和用过的survivor。
 *       Hotspot虚拟机默认eden和survivor的大小比例是8：1，也就是说每次只要10%的内存是浪费的
 *  10. 标记-整理算法（Mark-Compact） ：
 *       标记过程是一样的，但后续步骤不是进行直接清理，而是令所有存活的对象一端移动，然后直接清理掉这端边界以外的内存
 *       没有内存碎片、比Mark-Sweep耗费更多的时间进行Compact
 *  11. 分代收集（Generational Collecting）算法
 *       一般是把java堆分成新生代与老年代，这样可以根据各个年代的特点采用最适当的收集算法。譬如新生代每次GC都有大批对象
 *       死去，只有少量存活，那就选用复制算法只需付出少量对象的复制成本就可以完成收集。
 *  12. Hotspot将引用分成四种：Strong、Soft、Weak、Phantom
 *         Strong即默认通过Object o = new Object()这种方式赋值的引用
 *         Soft、Weak、Phantom这三种则都是继承于Reference，在进行FullGC时会对Reference类型的引用做特殊处理：
 *              Soft：内存不够时一定会被GC、长期不用也会被GC
 *              Weak：一定会被GC，当被mark为dead，会在ReferenceQueue中通知
 *              Phantom：本来就没有引用，当从jvm heap中释放时会被通知
 *  13. GC的时机
 *
 *  14. 垃圾收集器的并发与并行
 *      并行（Parallel）：指多个收集器的线程同时工作，但是用户线程处于等待状态
 *      并发（Concurrent）：指收集器在工作的同时，可以允许用户线程工作。并发并不代表解决了GC停顿问题，在关键步骤
 *                     还是要停顿。比如在收集器标记垃圾时用户线程停顿，但在清除垃圾时，用户线程与GC线程并发执行
 *  15. ParNew收集器是Serial的多线程版本，除了使用多个收集线程外，其余行为包括算法、STW、对象分配规则、回收策略等
 *      都与Serial收集器一模一样。是虚拟机运行在Server模式的默认新生代收集器。通过-XX:ParallelGCThreads来控制GC线程的数量。
 *  16. Parallel Scavenge收集器也是一个多线程收集器，也是使用复制算法，但它的对象分配规则与回收策略与ParNew收集器有所不同，
 *      它是以吞吐量最大化（即GC时间占总运行时间最小）为目标的收集器实现。它允许较长的STW换取总吞吐量最大化。
 *
 *  17. Parallel Old：是Parallel Scavenge在老年代的实现，在1.6引入。
 *         采用多线程，Mark-Compact算法，更注重吞吐量。Parallel Scavenge + Parallel Old = 高吞吐，但GC停顿时间可能不理想
 *  18. CMS（Concurrent Mark Sweep）收集器
 *         是一种以最短停顿时间为目标的收集器，使用CMS并不能达到GC效率最高，但它能尽可能降低GC时服务停顿时间，CMS收集器使用的是标记清除算法
 *
 *  19. Java内存泄漏的经典原因
 *      1. 对象定义在错误的范围
 *      2. 异常处理不当
 *      3. 集合管理不当
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
public class GcTheory {
}
